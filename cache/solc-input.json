{
  "language": "Solidity",
  "sources": {
    "contracts/Atomic.sol": {
      "content": "pragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./Create2.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n// atomicProxy CANNOT have a constructor, deployed code is used for deployment\ncontract AtomicProxy {\n    address payable public owner; \n    address payable public factory;\n    \n    constructor() public {\n        owner = tx.origin;\n        factory = msg.sender;\n    }\n    \n    receive() external payable {}\n\n    fallback () external payable {\n        (bool success, ) = factory.delegatecall(msg.data);\n        if (!success) {\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n}\n\ncontract Atomic {\n    address payable public owner = msg.sender;\n    address payable private factory; //needed to keep the storage layout equal to AtomicProxy\n    mapping (address => uint) public atomicNonce;\n    bytes proxyBytecode;\n    event atomicLaunch(address atomicContract);\n    \n    constructor (bytes memory _proxyBytecode) public {\n        proxyBytecode = _proxyBytecode;\n    }\n    \n    function launchAtomic(address[] calldata _to, uint[] calldata _value, bytes[] calldata _data) external payable returns (bool success) {\n        require (_to.length == _value.length && _value.length == _data.length, \"Parameters are incorrect\");\n        \n        address payable atomicProxy = Create2.deploy(getSalt(msg.sender), proxyBytecode);\n        atomicNonce[msg.sender]++;\n        emit atomicLaunch(atomicProxy);\n        \n        bytes memory txData = abi.encodeWithSelector(\n                Atomic.execute.selector,\n                _to,\n                _value,\n                _data\n            );\n        (success, ) = atomicProxy.call{value: msg.value}(txData);\n        if (!success) {\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n        // atomicInterface.drain(address(0));\n    }\n    \n    function getNextAtomic(address _owner) public view returns (address) {\n        return Create2.computeAddress(\n            getSalt(_owner),\n            proxyBytecode\n        );\n    }\n    \n    function getSalt(address _owner) internal view returns (bytes32 salt) {\n        return keccak256(abi.encodePacked(_owner,atomicNonce[_owner]));\n    }\n    \n    function execute(address[] calldata _to, uint[] calldata _value, bytes[] calldata _data) payable external returns (bool success) {\n        // require (time == now, \"Execution can only be performed once\");\n        for (uint i = 0; i < _data.length; i++) {\n            (success, ) = payable(_to[i]).call{value: _value[i]}(_data[i]);\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n    \n    function drain(address _token) public {\n        if (_token == address(0))\n            owner.call{value: address(this).balance}(\"\");\n        else {\n            IERC20 token = IERC20(_token);\n            token.transfer(owner, token.balanceOf(address(this)));\n        }\n    }\n    \n    fallback () external payable {\n        revert(\"Not correctly encoded for execute or drain.\");\n    }\n}\n\ncontract receiver {\n    \n    function balance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    fallback () external payable {\n        // revert(\"fallback do receiver\");\n    }\n    \n}"
    },
    "contracts/Create2.sol": {
      "content": "// Taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/970f687f04d20e01138a3e8ccf9278b1d4b3997b/contracts/utils/Create2.sol\n\npragma solidity ^0.6.6;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}. Note that\n     * a contract cannot be deployed twice using the same salt.\n     */\n    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address payable) {\n        address payable addr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"CREATE2_FAILED\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the `bytecode`\n     * or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes memory bytecode) internal view returns (address) {\n        return computeAddress(salt, bytecode, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes memory bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 bytecodeHashHash = keccak256(bytecodeHash);\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHashHash)\n        );\n        return address(bytes20(_data << 96));\n    }\n}\n"
    },
    "contracts/ContractWithFlashLoan.sol": {
      "content": "// pragma solidity ^0.5.0;\n// pragma experimental ABIEncoderV2;\n\n// import \"@studydefi/money-legos/aave/contracts/ILendingPool.sol\";\n// import \"@studydefi/money-legos/aave/contracts/IFlashLoanReceiver.sol\";\n// import \"@studydefi/money-legos/aave/contracts/FlashloanReceiverBase.sol\";\n\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// contract ContractWithFlashLoan is FlashLoanReceiverBase {\n//     address constant AaveLendingPoolAddressProviderAddress = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n//     struct MyCustomData {\n//         address a;\n//         uint b;\n//     }\n\n//     function executeOperation(\n//         address _reserve,\n//         uint _amount,\n//         uint _fee,\n//         bytes calldata _params\n//     ) external {\n//         // You can pass in some byte-encoded params\n//         MyCustomData memory myCustomData = abi.decode(_params, (MyCustomData));\n//         // myCustomData.a\n\n//         // Function is called when loan is given to contract\n//         // Do your logic here, e.g. arbitrage, liquidate compound, etc\n//         // Note that if you don't do your logic, it WILL fail\n\n//         // TODO: Change line below\n//         revert(\"Hello, you haven't implemented your flashloan logic\");\n\n//         transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n//     }\n\n//     // Entry point\n//     function initateFlashLoan(\n//         address contractWithFlashLoan,\n//         address assetToFlashLoan,\n//         uint amountToLoan,\n//         bytes calldata _params\n//     ) external {\n//         // Get Aave lending pool\n//         ILendingPool lendingPool = ILendingPool(\n//             ILendingPoolAddressesProvider(AaveLendingPoolAddressProviderAddress)\n//                 .getLendingPool()\n//         );\n\n//         // Ask for a flashloan\n//         // LendingPool will now execute the `executeOperation` function above\n//         lendingPool.flashLoan(\n//             contractWithFlashLoan, // Which address to callback into, alternatively: address(this)\n//             assetToFlashLoan,\n//             amountToLoan,\n//             _params\n//         );\n//     }\n// }"
    },
    "contracts/Loaner.sol": {
      "content": "\n\n// Single on chain contract that takes flash loans on behalf of msg.sender(an atomic contract).\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// import \"@studydefi/money-legos/aave/contracts/ILendingPool.sol\";\n// import \"@studydefi/money-legos/aave/contracts/ILendingPoolAddressesProvider.sol\";\nimport \"./MockAave.sol\";\nimport \"./MockAtomic.sol\";\n\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n}\ninterface ILendingPool {\n  function addressesProvider () external view returns ( address );\n  function deposit ( address _reserve, uint256 _amount, uint16 _referralCode ) external payable;\n  function redeemUnderlying ( address _reserve, address _user, uint256 _amount ) external;\n  function borrow ( address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode ) external;\n  function repay ( address _reserve, uint256 _amount, address _onBehalfOf ) external payable;\n  function swapBorrowRateMode ( address _reserve ) external;\n  function rebalanceFixedBorrowRate ( address _reserve, address _user ) external;\n  function setUserUseReserveAsCollateral ( address _reserve, bool _useAsCollateral ) external;\n  function liquidationCall ( address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveAToken ) external payable;\n  function flashLoan ( address _receiver, address _reserve, uint256 _amount, bytes calldata _params ) external;\n  function getReserveConfigurationData ( address _reserve ) external view returns ( uint256 ltv, uint256 liquidationThreshold, uint256 liquidationDiscount, address interestRateStrategyAddress, bool usageAsCollateralEnabled, bool borrowingEnabled, bool fixedBorrowRateEnabled, bool isActive );\n  function getReserveData ( address _reserve ) external view returns ( uint256 totalLiquidity, uint256 availableLiquidity, uint256 totalBorrowsFixed, uint256 totalBorrowsVariable, uint256 liquidityRate, uint256 variableBorrowRate, uint256 fixedBorrowRate, uint256 averageFixedBorrowRate, uint256 utilizationRate, uint256 liquidityIndex, uint256 variableBorrowIndex, address aTokenAddress, uint40 lastUpdateTimestamp );\n  function getUserAccountData ( address _user ) external view returns ( uint256 totalLiquidityETH, uint256 totalCollateralETH, uint256 totalBorrowsETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );\n  function getUserReserveData ( address _reserve, address _user ) external view returns ( uint256 currentATokenBalance, uint256 currentUnderlyingBalance, uint256 currentBorrowBalance, uint256 principalBorrowBalance, uint256 borrowRateMode, uint256 borrowRate, uint256 liquidityRate, uint256 originationFee, uint256 variableBorrowIndex, uint256 lastUpdateTimestamp, bool usageAsCollateralEnabled );\n  function getReserves () external view;\n}\n\ncontract Loaner {\n\n    address payable public sender;\n    address constant ETHADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ILendingPoolAddressesProvider public addressesProvider = ILendingPoolAddressesProvider(\n        0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\n    );\n\n    uint public debug;\n    bytes public dby;\n    function initateFlashLoan(\n        address assetToFlashLoan,\n        uint amountToLoan,\n        bytes calldata _params) \n        external payable{\n            sender = msg.sender;\n            //Get Aave lending pool\n            ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());\n            // // Ask for a flashloan\n            // // LendingPool will now execute the `executeOperation` function above\n            lendingPool.flashLoan(\n                address(this), // Which address to callback into, alternatively: address(this)\n                assetToFlashLoan,\n                amountToLoan,\n                _params\n            );\n    }\n\n    function initateFlash(\n        address payable assetToFlashLoan,\n        uint amountToLoan,\n        bytes calldata _params) \n        external payable{\n            sender = msg.sender;\n            //Get Aave lending pool\n            // ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());\n            // // Ask for a flashloan\n            // // LendingPool will now execute the `executeOperation` function above\n            MockAave m = MockAave(assetToFlashLoan);\n            m.flashLoan(\n                address(this), // Which address to callback into, alternatively: address(this)\n                assetToFlashLoan,\n                amountToLoan,\n                _params\n            );\n\n            // address payable core =  0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n            // core.transfer(address(this).balance);\n    }\n\n    function executeOperation(\n        address _reserve,\n        uint _amount,\n        uint _fee,\n        bytes calldata _params\n    ) external {\n        // address payable core =  0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n        // core.call.value(_amount + _fee)(\"\");\n        //We need to transfer the asset to the reciever.\n        // if(_reserve != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE){\n        //     IERC20(_reserve).transfer(sender, _amount);\n        // }\n        // sender.transfer(1);\n        // MockAtomic ma = MockAtomic(sender);\n        // bool a = ma.execc();\n        (bool succ,) = sender.call.value(_amount).gas(gasleft())(_params);\n        require(succ, \"something here\");\n        // sender.call.value(address(this).balance);\n        // sender = msg.sender;\n    }\n\n    fallback() external payable {\n\n    }\n}"
    },
    "contracts/MockAave.sol": {
      "content": "pragma solidity 0.6.8;\n\nimport \"./Loaner.sol\";\n\ncontract MockAave {\n\n    uint public _amount;\n    uint public _fee;\n\n    constructor() public payable {\n\n    }\n\n    function flashLoan(address payable reciever, address asset, uint amount, bytes calldata _params) external {\n        reciever.call.value(amount)(\"\");\n        uint fee = amount * 9 / 10000;\n        Loaner(reciever).executeOperation(asset,amount,fee,_params);\n    }\n\n    fallback() external payable {}\n}"
    },
    "contracts/MockAtomic.sol": {
      "content": "pragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\n\nimport \"./Atomic.sol\";\n\ncontract MockAtomic{\n\n    uint public valueRec;\n\n    constructor(address factory, bytes memory transactions) public payable {\n    }\n\n    // function exec(bytes memory transactions) public payable {\n    //     valueRec = 2323;\n    //     // dd = transactions;\n    //     assembly {\n    //         let length := mload(transactions)\n    //         let i := 0x20\n    //         for { } lt(i, length) { } {\n    //             let to := mload(add(transactions, i))\n    //             let value := mload(add(transactions, add(i, 0x20)))\n    //             let dataLength := mload(add(transactions, add(i, 0x60)))\n    //             let data := add(transactions, add(i, 0x80))\n    //             let success := call(210000000000000, to, value, data, dataLength, 0, 0)\n    //             if eq(success, 0) { revert(0, \"One of the transactions failed\") }\n    //             i := add(i, add(0x80, mul(div(add(dataLength, 0x1f), 0x20), 0x20)))\n    //         }\n    //     }\n    // }\n\n    // function execc() public payable returns(bool){\n    //     // dd = transactions;\n    //     valueRec = 6666699;\n    //     return true;\n    // }\n\n    fallback() external payable {\n        valueRec = 333;\n        // valueRec = msg.value;\n        // dd = msg.data;\n        // exec(msg.data);\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}