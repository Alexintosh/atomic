{
  "language": "Solidity",
  "sources": {
    "contracts/Atomic.sol": {
      "content": "pragma solidity 0.5.15;\n\ncontract Atomic {\n\n    /// @dev Sends multiple transactions and reverts all if one fails, self destructs immediately\n    /// @param transactions Encoded transactions. Each transaction is encoded as a\n    ///                     tuple(address,uint256,bytes). The bytes\n    ///                     of all encoded transactions are concatenated to form the input.\n    constructor(bytes memory transactions) public payable {\n        exec(transactions);\n    }\n\n    bytes public dd;\n\n    function exec(bytes memory transactions) public payable {\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for { } lt(i, length) { } {\n                let to := mload(add(transactions, i))\n                let value := mload(add(transactions, add(i, 0x20)))\n                let dataLength := mload(add(transactions, add(i, 0x60)))\n                let data := add(transactions, add(i, 0x80))\n                let success := call(210000000000000, to, value, data, dataLength, 0, 0)\n                if eq(success, 0) { revert(0, \"One of the transactions failed\") }\n                i := add(i, add(0x80, mul(div(add(dataLength, 0x1f), 0x20), 0x20)))\n            }\n        }\n    }\n\n    // function() external payable {\n    //     //dd = msg.data;\n    //     //exec(msg.data);\n    //     // address payable s = 0x9C65C5A69e69C67E8e340e893CfCa9A0844d4800;\n    //     // s.transfer(msg.value);\n    // }\n}"
    },
    "contracts/ContractWithFlashLoan.sol": {
      "content": "pragma solidity ^0.5.0;\npragma experimental ABIEncoderV2;\n\nimport \"@studydefi/money-legos/aave/contracts/ILendingPool.sol\";\nimport \"@studydefi/money-legos/aave/contracts/IFlashLoanReceiver.sol\";\nimport \"@studydefi/money-legos/aave/contracts/FlashloanReceiverBase.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ContractWithFlashLoan is FlashLoanReceiverBase {\n    address constant AaveLendingPoolAddressProviderAddress = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n    struct MyCustomData {\n        address a;\n        uint b;\n    }\n\n    function executeOperation(\n        address _reserve,\n        uint _amount,\n        uint _fee,\n        bytes calldata _params\n    ) external {\n        // You can pass in some byte-encoded params\n        MyCustomData memory myCustomData = abi.decode(_params, (MyCustomData));\n        // myCustomData.a\n\n        // Function is called when loan is given to contract\n        // Do your logic here, e.g. arbitrage, liquidate compound, etc\n        // Note that if you don't do your logic, it WILL fail\n\n        // TODO: Change line below\n        revert(\"Hello, you haven't implemented your flashloan logic\");\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n    }\n\n    // Entry point\n    function initateFlashLoan(\n        address contractWithFlashLoan,\n        address assetToFlashLoan,\n        uint amountToLoan,\n        bytes calldata _params\n    ) external {\n        // Get Aave lending pool\n        ILendingPool lendingPool = ILendingPool(\n            ILendingPoolAddressesProvider(AaveLendingPoolAddressProviderAddress)\n                .getLendingPool()\n        );\n\n        // Ask for a flashloan\n        // LendingPool will now execute the `executeOperation` function above\n        lendingPool.flashLoan(\n            contractWithFlashLoan, // Which address to callback into, alternatively: address(this)\n            assetToFlashLoan,\n            amountToLoan,\n            _params\n        );\n    }\n}"
    },
    "@studydefi/money-legos/aave/contracts/ILendingPool.sol": {
      "content": "pragma solidity ^0.5.0;\n\ninterface ILendingPool {\n  function addressesProvider () external view returns ( address );\n  function deposit ( address _reserve, uint256 _amount, uint16 _referralCode ) external payable;\n  function redeemUnderlying ( address _reserve, address _user, uint256 _amount ) external;\n  function borrow ( address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode ) external;\n  function repay ( address _reserve, uint256 _amount, address _onBehalfOf ) external payable;\n  function swapBorrowRateMode ( address _reserve ) external;\n  function rebalanceFixedBorrowRate ( address _reserve, address _user ) external;\n  function setUserUseReserveAsCollateral ( address _reserve, bool _useAsCollateral ) external;\n  function liquidationCall ( address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveAToken ) external payable;\n  function flashLoan ( address _receiver, address _reserve, uint256 _amount, bytes calldata _params ) external;\n  function getReserveConfigurationData ( address _reserve ) external view returns ( uint256 ltv, uint256 liquidationThreshold, uint256 liquidationDiscount, address interestRateStrategyAddress, bool usageAsCollateralEnabled, bool borrowingEnabled, bool fixedBorrowRateEnabled, bool isActive );\n  function getReserveData ( address _reserve ) external view returns ( uint256 totalLiquidity, uint256 availableLiquidity, uint256 totalBorrowsFixed, uint256 totalBorrowsVariable, uint256 liquidityRate, uint256 variableBorrowRate, uint256 fixedBorrowRate, uint256 averageFixedBorrowRate, uint256 utilizationRate, uint256 liquidityIndex, uint256 variableBorrowIndex, address aTokenAddress, uint40 lastUpdateTimestamp );\n  function getUserAccountData ( address _user ) external view returns ( uint256 totalLiquidityETH, uint256 totalCollateralETH, uint256 totalBorrowsETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );\n  function getUserReserveData ( address _reserve, address _user ) external view returns ( uint256 currentATokenBalance, uint256 currentUnderlyingBalance, uint256 currentBorrowBalance, uint256 principalBorrowBalance, uint256 borrowRateMode, uint256 borrowRate, uint256 liquidityRate, uint256 originationFee, uint256 variableBorrowIndex, uint256 lastUpdateTimestamp, bool usageAsCollateralEnabled );\n  function getReserves () external view;\n}\n"
    },
    "@studydefi/money-legos/aave/contracts/IFlashLoanReceiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ILendingPoolAddressesProvider.sol\";\n\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params\n    ) external;\n}\n\n\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@studydefi/money-legos/aave/contracts/ILendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n@title ILendingPoolAddressesProvider interface\n@notice provides the interface to fetch the LendingPoolCore address\n */\n\ncontract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public view returns (address);\n    function setLendingPoolImpl(address _pool) public;\n\n    function getLendingPoolCore() public view returns (address payable);\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\n\n    function getLendingPoolConfigurator() public view returns (address);\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\n\n    function getLendingPoolDataProvider() public view returns (address);\n    function setLendingPoolDataProviderImpl(address _provider) public;\n\n    function getLendingPoolParametersProvider() public view returns (address);\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\n\n    function getTokenDistributor() public view returns (address);\n    function setTokenDistributor(address _tokenDistributor) public;\n\n    function getFeeProvider() public view returns (address);\n    function setFeeProviderImpl(address _feeProvider) public;\n\n    function getLendingPoolLiquidationManager() public view returns (address);\n    function setLendingPoolLiquidationManager(address _manager) public;\n\n    function getLendingPoolManager() public view returns (address);\n    function setLendingPoolManager(address _lendingPoolManager) public;\n\n    function getPriceOracle() public view returns (address);\n    function setPriceOracle(address _priceOracle) public;\n\n    function getLendingRateOracle() public view returns (address);\n    function setLendingRateOracle(address _lendingRateOracle) public;\n\n}"
    },
    "@studydefi/money-legos/aave/contracts/FlashloanReceiverBase.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IFlashLoanReceiver.sol\";\n\n\ncontract FlashLoanReceiverBase is IFlashLoanReceiver {\n    using SafeMath for uint256;\n\n    address constant ETHADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    ILendingPoolAddressesProvider public addressesProvider = ILendingPoolAddressesProvider(\n        0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\n    );\n\n    function() external payable {}\n\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount)\n        internal\n    {\n        address payable core = addressesProvider.getLendingPoolCore();\n        transferInternal(core, _reserve, _amount);\n    }\n\n    function transferInternal(\n        address payable _destination,\n        address _reserve,\n        uint256 _amount\n    ) internal {\n        if (_reserve == ETHADDRESS) {\n            //solium-disable-next-line\n            _destination.call.value(_amount)(\"\");\n            return;\n        }\n\n        IERC20(_reserve).transfer(_destination, _amount);\n    }\n\n    function getBalanceInternal(address _target, address _reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_reserve == ETHADDRESS) {\n            return _target.balance;\n        }\n\n        return IERC20(_reserve).balanceOf(_target);\n    }\n}\n"
    },
    "contracts/Loaner.sol": {
      "content": "// Single on chain contract that takes flash loans on behalf of msg.sender(an atomic contract).\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@studydefi/money-legos/aave/contracts/ILendingPool.sol\";\nimport \"@studydefi/money-legos/aave/contracts/ILendingPoolAddressesProvider.sol\";\nimport \"./MockAave.sol\";\nimport \"./MockAtomic.sol\";\n\ncontract Loaner {\n\n    address payable public sender;\n    address constant ETHADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address constant AaveLendingPoolAddressProviderAddress = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n    ILendingPoolAddressesProvider public addressesProvider = ILendingPoolAddressesProvider(\n        0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\n    );\n\n    uint public debug;\n    bytes public dby;\n    function initateFlashLoan(\n        address assetToFlashLoan,\n        uint amountToLoan,\n        bytes calldata _params) \n        external payable{\n            sender = msg.sender;\n            //Get Aave lending pool\n            ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());\n            // // Ask for a flashloan\n            // // LendingPool will now execute the `executeOperation` function above\n            lendingPool.flashLoan(\n                address(this), // Which address to callback into, alternatively: address(this)\n                assetToFlashLoan,\n                amountToLoan,\n                _params\n            );\n\n            // address payable core =  0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n            // core.transfer(address(this).balance);\n    }\n\n    function initateFlash(\n        address payable assetToFlashLoan,\n        uint amountToLoan,\n        bytes calldata _params) \n        external payable{\n            sender = msg.sender;\n            //Get Aave lending pool\n            // ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());\n            // // Ask for a flashloan\n            // // LendingPool will now execute the `executeOperation` function above\n            MockAave m = MockAave(assetToFlashLoan);\n            m.flashLoan(\n                address(this), // Which address to callback into, alternatively: address(this)\n                assetToFlashLoan,\n                amountToLoan,\n                _params\n            );\n\n            // address payable core =  0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n            // core.transfer(address(this).balance);\n    }\n\n    function executeOperation(\n        address _reserve,\n        uint _amount,\n        uint _fee,\n        bytes calldata _params\n    ) external {\n        // address payable core =  0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n        // core.call.value(_amount + _fee)(\"\");\n        //We need to transfer the asset to the reciever.\n        // if(_reserve != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE){\n        //     IERC20(_reserve).transfer(sender, _amount);\n        // }\n        // sender.transfer(1);\n        // MockAtomic ma = MockAtomic(sender);\n        // bool a = ma.execc();\n        (bool succ,) = sender.call.value(_amount)(_params);\n        // debug = succ? 22: 11;\n        // require(succ, \"something here\");\n        // sender.call.value(address(this).balance);\n        // sender = msg.sender;\n    }\n\n    function() external payable {\n\n    }\n}"
    },
    "contracts/MockAave.sol": {
      "content": "pragma solidity 0.5.15;\n\nimport \"./Loaner.sol\";\n\ncontract MockAave {\n\n    uint public _amount;\n    uint public _fee;\n\n    constructor() public payable {\n\n    }\n\n    function flashLoan(address payable reciever, address asset, uint amount, bytes calldata _params) external {\n        reciever.call.value(amount)(\"\");\n        uint fee = amount * 9 / 10000;\n        Loaner(reciever).executeOperation(asset,amount,fee,_params);\n    }\n\n    function() external payable {\n\n    } \n}"
    },
    "contracts/MockAtomic.sol": {
      "content": "pragma solidity 0.5.15;\n\nimport \"./Atomic.sol\";\n\ncontract MockAtomic is Atomic {\n\n    uint public valueRec;\n\n    constructor(bytes memory transactions) public payable Atomic(transactions){\n    }\n\n    function exec(bytes memory transactions) public payable {\n        // valueRec = 2323;\n        dd = transactions;\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for { } lt(i, length) { } {\n                let to := mload(add(transactions, i))\n                let value := mload(add(transactions, add(i, 0x20)))\n                let dataLength := mload(add(transactions, add(i, 0x60)))\n                let data := add(transactions, add(i, 0x80))\n                let success := call(210000000000000, to, value, data, dataLength, 0, 0)\n                // if eq(success, 0) { revert(0, \"One of the transactions failed\") }\n                i := add(i, add(0x80, mul(div(add(dataLength, 0x1f), 0x20), 0x20)))\n            }\n        }\n    }\n\n    function execc() public payable returns(bool){\n        // dd = transactions;\n        valueRec = 6666699;\n        return true;\n    }\n\n    function() external payable {\n        // valueRec = 333;\n        valueRec = msg.value;\n        // dd = msg.data;\n        // exec(msg.data);\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}