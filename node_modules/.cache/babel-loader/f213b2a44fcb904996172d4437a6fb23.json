{"ast":null,"code":"import _regeneratorRuntime from \"/Users/polaco/prog/atomic/atomic/node_modules/@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nBlockly.Blocks[\"uniswap_v1_swap\"] = {\n  /**\n   * @this Blockly.Block\n   */\n  init: function init() {\n    this.jsonInit({\n      message0: \"%1 %2 swap %3 %4 for %5\",\n      args0: [{\n        type: \"field_image\",\n        src: \"https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/apple/237/unicorn-face_1f984.png\",\n        width: 40,\n        height: 40\n      }, {\n        type: \"field_vertical_separator\"\n      }, {\n        type: \"input_value\",\n        name: \"VALUE\"\n      }, {\n        type: \"input_value\",\n        name: \"TOKEN\"\n      }, {\n        type: \"input_value\",\n        name: \"TOKEN2\"\n      }],\n      category: Blockly.Categories.pen,\n      extensions: [\"colours_more\", \"shape_statement\", \"scratch_extension\"]\n    });\n  },\n  encoder: function () {\n    var _encoder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(value, tokenFrom, tokenTo) {\n      var uniswapTestFactory, getExchange, uniswapExchangeInterface, erc20Interface, encoder, types, exchange, calldata, aproveCalldata, swapCalldata;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(tokenFrom == tokenTo)) {\n                _context2.next = 3;\n                break;\n              }\n\n              console.log(\"Error (uniswap_v1_swap): Cannot swap for the same token, please use different tokens from/to.\");\n              return _context2.abrupt(\"return\");\n\n            case 3:\n              // uniswap factory (to find out exchanges for tokens)\n              uniswapTestFactory = new ethers.Contract(legos.uniswap.factory.address, legos.uniswap.factory.abi, new ethers.getDefaultProvider()); // gets \n\n              getExchange = /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenAddress) {\n                  var exchangeAddress;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return uniswapTestFactory.getExchange(tokenAddress);\n\n                        case 2:\n                          exchangeAddress = _context.sent;\n                          return _context.abrupt(\"return\", exchangeAddress);\n\n                        case 4:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function getExchange(_x4) {\n                  return _ref.apply(this, arguments);\n                };\n              }();\n\n              uniswapExchangeInterface = new ethers.utils.Interface(legos.uniswap.exchange.abi);\n              erc20Interface = new ethers.utils.Interface(legos.erc20.abi); // encoding for atomic\n\n              encoder = new ethers.utils.AbiCoder();\n              types = [\"address\", \"uint256\", \"bytes\"]; // to, value, data\n\n              if (!(tokenFrom == \"0x0\")) {\n                _context2.next = 15;\n                break;\n              }\n\n              _context2.next = 12;\n              return getExchange(tokenTo);\n\n            case 12:\n              _context2.t0 = _context2.sent;\n              _context2.next = 18;\n              break;\n\n            case 15:\n              _context2.next = 17;\n              return getExchange(tokenFrom);\n\n            case 17:\n              _context2.t0 = _context2.sent;\n\n            case 18:\n              exchange = _context2.t0;\n\n              if (!(tokenFrom == \"0x0\")) {\n                _context2.next = 24;\n                break;\n              }\n\n              // from ether to token\n              calldata = uniswapExchangeInterface.functions.ethToTokenSwapInput.encode([\"2\", Math.floor(Date.now() / 1000) + 300]);\n              return _context2.abrupt(\"return\", encoder.encode(types, [exchange, ethers.utils.parseEther(value), calldata]).slice(2));\n\n            case 24:\n              aproveCalldata = erc20Interface.functions.approve.encode([exchange, ethers.utils.parseEther(value)]);\n\n              if (tokenTo == \"0x0\") {\n                // from token to ether\n                swapCalldata = uniswapExchangeInterface.functions.tokenToEthSwapInput.encode([ethers.utils.parseEther(value), \"1\", Math.floor(Date.now() / 1000) + 300]);\n              } else {\n                // token to token\n                swapCalldata = uniswapExchangeInterface.functions.tokenToTokenSwapInput.encode([ethers.utils.parseEther(value), \"1\", \"1\", Math.floor(Date.now() / 1000) + 300, tokenTo]);\n              }\n\n              return _context2.abrupt(\"return\", encoder.encode(types, [tokenFrom, \"0\", aproveCalldata]).slice(2) + encoder.encode(types, [exchange, \"0\", swapCalldata]).slice(2));\n\n            case 27:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function encoder(_x, _x2, _x3) {\n      return _encoder.apply(this, arguments);\n    }\n\n    return encoder;\n  }(),\n  template: function template() {\n    return \"\" + '<block type=\"uniswap_v1_swap\" id=\"uniswap_v1_swap\">' + '<value name=\"VALUE\">' + '<shadow type=\"math_number\">' + '<field name=\"NUM\">10</field>' + '</shadow>' + '</value>' + '<value name=\"TOKEN\">' + '<shadow type=\"uniswap_token_list\"></shadow>' + '</value>' + '<value name=\"TOKEN2\">' + '<shadow type=\"uniswap_token_list\"></shadow>' + '</value>' + '</block>';\n  }\n};\nBlockly.Blocks[\"uniswap_token_list\"] = {\n  /**\n   * @this Blockly.Block\n   */\n  init: function init() {\n    this.jsonInit({\n      message0: \"%1\",\n      args0: [{\n        type: \"field_dropdown\",\n        name: \"TOKEN\",\n        options: [[\"ETH\", \"0x0\"], [\"DAI\", \"0x6b175474e89094c44da98b954eedeac495271d0f\"], [\"BAT\", \"0x0d8775f648430679a709e98d2b0cb6250d2887ef\"], [\"WETH\", \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"]]\n      }],\n      extensions: [\"colours_more\", \"output_string\"]\n    });\n  }\n};","map":{"version":3,"sources":["/Users/polaco/prog/atomic/atomic/blocks/uniswap_v1_swap.js"],"names":["Blockly","Blocks","init","jsonInit","message0","args0","type","src","width","height","name","category","Categories","pen","extensions","encoder","value","tokenFrom","tokenTo","console","log","uniswapTestFactory","ethers","Contract","legos","uniswap","factory","address","abi","getDefaultProvider","getExchange","tokenAddress","exchangeAddress","uniswapExchangeInterface","utils","Interface","exchange","erc20Interface","erc20","AbiCoder","types","calldata","functions","ethToTokenSwapInput","encode","Math","floor","Date","now","parseEther","slice","aproveCalldata","approve","swapCalldata","tokenToEthSwapInput","tokenToTokenSwapInput","template","options"],"mappings":"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","sourcesContent":["Blockly.Blocks[\"uniswap_v1_swap\"] = {\n  /**\n   * @this Blockly.Block\n   */\n  init: function () {\n    this.jsonInit({\n      message0: \"%1 %2 swap %3 %4 for %5\",\n      args0: [{\n          type: \"field_image\",\n          src: \"https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/apple/237/unicorn-face_1f984.png\",\n          width: 40,\n          height: 40,\n        },\n        {\n          type: \"field_vertical_separator\",\n        },\n        {\n          type: \"input_value\",\n          name: \"VALUE\",\n        },\n        {\n          type: \"input_value\",\n          name: \"TOKEN\",\n        },\n        {\n          type: \"input_value\",\n          name: \"TOKEN2\",\n        },\n      ],\n      category: Blockly.Categories.pen,\n      extensions: [\"colours_more\", \"shape_statement\", \"scratch_extension\"],\n    });\n  },\n  encoder: async function (value, tokenFrom, tokenTo) {\n    if (tokenFrom == tokenTo) {\n      console.log(\"Error (uniswap_v1_swap): Cannot swap for the same token, please use different tokens from/to.\")\n      return\n    }\n\n    // uniswap factory (to find out exchanges for tokens)\n    let uniswapTestFactory = new ethers.Contract(legos.uniswap.factory.address, legos.uniswap.factory.abi, new ethers.getDefaultProvider());\n\n    // gets \n    let getExchange = async (tokenAddress) => {\n      let exchangeAddress = await uniswapTestFactory.getExchange(tokenAddress)\n      return exchangeAddress\n    }\n\n    let uniswapExchangeInterface = new ethers.utils.Interface(legos.uniswap.exchange.abi);\n    let erc20Interface = new ethers.utils.Interface(legos.erc20.abi)\n\n    // encoding for atomic\n    let encoder = new ethers.utils.AbiCoder();\n    let types = [\"address\", \"uint256\", \"bytes\"]; // to, value, data\n\n    let exchange = (tokenFrom == \"0x0\") ? await getExchange(tokenTo) : await getExchange(tokenFrom)\n\n    if (tokenFrom == \"0x0\") { // from ether to token\n\n      let calldata = uniswapExchangeInterface.functions.ethToTokenSwapInput.encode([\"2\", Math.floor(Date.now() / 1000) + 300])\n      return encoder.encode(types, [exchange, ethers.utils.parseEther(value), calldata]).slice(2)\n\n    } else {\n\n      let aproveCalldata = erc20Interface.functions.approve.encode([exchange, ethers.utils.parseEther(value)])\n      let swapCalldata\n\n      if (tokenTo == \"0x0\") { // from token to ether\n        swapCalldata = uniswapExchangeInterface.functions.tokenToEthSwapInput.encode([ethers.utils.parseEther(value), \"1\", Math.floor(Date.now() / 1000) + 300])\n      } else { // token to token\n        swapCalldata = uniswapExchangeInterface.functions.tokenToTokenSwapInput.encode([ethers.utils.parseEther(value), \"1\", \"1\", Math.floor(Date.now() / 1000) + 300, tokenTo])\n      }\n\n      return encoder.encode(types, [tokenFrom, \"0\", aproveCalldata]).slice(2) + encoder.encode(types, [exchange, \"0\", swapCalldata]).slice(2)\n\n    }\n  },\n  template: function () {\n    return \"\" +\n      '<block type=\"uniswap_v1_swap\" id=\"uniswap_v1_swap\">' +\n      '<value name=\"VALUE\">' +\n      '<shadow type=\"math_number\">' +\n      '<field name=\"NUM\">10</field>' +\n      '</shadow>' +\n      '</value>' +\n      '<value name=\"TOKEN\">' +\n      '<shadow type=\"uniswap_token_list\"></shadow>' +\n      '</value>' +\n      '<value name=\"TOKEN2\">' +\n      '<shadow type=\"uniswap_token_list\"></shadow>' +\n      '</value>' +\n      '</block>'\n  }\n};\n\nBlockly.Blocks[\"uniswap_token_list\"] = {\n  /**\n   * @this Blockly.Block\n   */\n  init: function () {\n    this.jsonInit({\n      message0: \"%1\",\n      args0: [{\n        type: \"field_dropdown\",\n        name: \"TOKEN\",\n        options: [\n          [\"ETH\", \"0x0\"],\n          [\"DAI\", \"0x6b175474e89094c44da98b954eedeac495271d0f\"],\n          [\"BAT\", \"0x0d8775f648430679a709e98d2b0cb6250d2887ef\"],\n          [\"WETH\", \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"],\n        ],\n      }, ],\n      extensions: [\"colours_more\", \"output_string\"],\n    });\n  },\n};"]},"metadata":{},"sourceType":"module"}